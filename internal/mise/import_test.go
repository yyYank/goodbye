package mise

import (
	"reflect"
	"testing"
)

func TestParseTOML(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected []InstalledTool
		wantErr  bool
	}{
		{
			name:     "empty content",
			input:    "",
			expected: nil,
			wantErr:  false,
		},
		{
			name: "single tool",
			input: `[tools]
node = "20.10.0"`,
			expected: []InstalledTool{
				{Name: "node", Version: "20.10.0"},
			},
			wantErr: false,
		},
		{
			name: "multiple tools",
			input: `[tools]
node = "20.10.0"
python = "3.12.0"
go = "1.21.5"`,
			expected: []InstalledTool{
				{Name: "node", Version: "20.10.0"},
				{Name: "python", Version: "3.12.0"},
				{Name: "go", Version: "1.21.5"},
			},
			wantErr: false,
		},
		{
			name: "with comments and header",
			input: `# Generated by goodbye export mise
[tools]
# Development tools
node = "20.10.0"
python = "3.12.0"`,
			expected: []InstalledTool{
				{Name: "node", Version: "20.10.0"},
				{Name: "python", Version: "3.12.0"},
			},
			wantErr: false,
		},
		{
			name: "with single quotes",
			input: `[tools]
node = '20.10.0'`,
			expected: []InstalledTool{
				{Name: "node", Version: "20.10.0"},
			},
			wantErr: false,
		},
		{
			name: "with other sections",
			input: `[settings]
experimental = true

[tools]
node = "20.10.0"

[env]
FOO = "bar"`,
			expected: []InstalledTool{
				{Name: "node", Version: "20.10.0"},
			},
			wantErr: false,
		},
		{
			name: "array format single",
			input: `[tools]
python = ["3.12.0"]`,
			expected: []InstalledTool{
				{Name: "python", Version: "3.12.0"},
			},
			wantErr: false,
		},
		{
			name: "array format multiple versions",
			input: `[tools]
python = ["3.12.0", "3.11.0"]`,
			expected: []InstalledTool{
				{Name: "python", Version: "3.12.0"},
				{Name: "python", Version: "3.11.0"},
			},
			wantErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := ParseTOML(tt.input)
			if (err != nil) != tt.wantErr {
				t.Errorf("ParseTOML() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(result, tt.expected) {
				t.Errorf("ParseTOML() = %v, want %v", result, tt.expected)
			}
		})
	}
}

func TestParseToolVersions(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected []InstalledTool
		wantErr  bool
	}{
		{
			name:     "empty content",
			input:    "",
			expected: nil,
			wantErr:  false,
		},
		{
			name:  "single tool",
			input: `node 20.10.0`,
			expected: []InstalledTool{
				{Name: "node", Version: "20.10.0"},
			},
			wantErr: false,
		},
		{
			name: "multiple tools",
			input: `node 20.10.0
python 3.12.0
go 1.21.5`,
			expected: []InstalledTool{
				{Name: "node", Version: "20.10.0"},
				{Name: "python", Version: "3.12.0"},
				{Name: "go", Version: "1.21.5"},
			},
			wantErr: false,
		},
		{
			name: "with comments",
			input: `# Generated by goodbye export mise
# Development tools
node 20.10.0
python 3.12.0`,
			expected: []InstalledTool{
				{Name: "node", Version: "20.10.0"},
				{Name: "python", Version: "3.12.0"},
			},
			wantErr: false,
		},
		{
			name: "with empty lines",
			input: `node 20.10.0

python 3.12.0
`,
			expected: []InstalledTool{
				{Name: "node", Version: "20.10.0"},
				{Name: "python", Version: "3.12.0"},
			},
			wantErr: false,
		},
		{
			name: "multiple versions per line",
			input: `python 3.12.0 3.11.0`,
			expected: []InstalledTool{
				{Name: "python", Version: "3.12.0"},
				{Name: "python", Version: "3.11.0"},
			},
			wantErr: false,
		},
		{
			name: "mixed single and multiple versions",
			input: `node 20.10.0
python 3.12.0 3.11.0
go 1.21.5`,
			expected: []InstalledTool{
				{Name: "node", Version: "20.10.0"},
				{Name: "python", Version: "3.12.0"},
				{Name: "python", Version: "3.11.0"},
				{Name: "go", Version: "1.21.5"},
			},
			wantErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := ParseToolVersions(tt.input)
			if (err != nil) != tt.wantErr {
				t.Errorf("ParseToolVersions() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(result, tt.expected) {
				t.Errorf("ParseToolVersions() = %v, want %v", result, tt.expected)
			}
		})
	}
}
